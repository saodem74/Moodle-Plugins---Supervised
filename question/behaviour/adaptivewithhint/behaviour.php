<?phpdefined('MOODLE_INTERNAL') || die();/** * Question behaviour for question with hints in adaptive mode. * * Behaviour variables: * _try - number of submissions (inherited from adaptive) * _rawfraction - fraction for the step without penalties (inherited from adaptive) * _hashint - there was hint requested in the step * _<hintname>count - count of hint named <hintname> * _totalpenalties - sum of all penalties already done * * Behaviour controls: * submit - submit answer to grading (inherited from adaptive) * <hintname>btn - buttons to get hint <hintname> * * @copyright  2011 Oleg Sychev Volgograd State Technical University * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later */require_once($CFG->dirroot . 'question/behaviour/adaptive/behaviour.php');class qbehaviour_adaptive_with_hints extends qbehaviour_adaptive {    const IS_ARCHETYPAL = false;    public static function get_required_behaviours() {        return array('qbehaviour_adaptive');    }    public function required_question_definition_type() {//TODO - it should also require question_with_specific_hints interface, but for now it is able to return only one type        return 'question_automatically_gradable';    }    public function get_expected_data() {        $expected = parent::get_expected_data();        if ($this->qa->get_state()->is_active()) {//returning an array of hint buttons            foreach ($this->question->available_specific_hint_types() as $hintkey => $hintdescription) {                $expected[$hintkey] = PARAM_BOOL;            }        }        return $expected;    }    public function adjust_display_options(question_display_options $options) {        parent::adjust_display_options($options);//there seems to nothing to be done until question_display_options will be passed to specific_feedback function of question renderer    }    public function summarise_action(question_attempt_step $step) {        //Summarise hint action        foreach ($this->question->available_specific_hint_types() as $hintkey => $hintdescription) {            if ($step->has_behaviour_var($hintkey.'btn')) {                return $this->summarise_hint($step, $hintkey, $hintdescription);            }        }        return parent::summarise_action($step);    }    public function summarise_hint(question_attempt_step $step, $hintkey, $hintdescription) {        $a = new stdClass();        $a->hint = $hintdescription;        $a->response = $this->question->summarise_response($step->get_qt_data());        return get_string('hintused', 'adaptivewithhint', $a);    }    public function process_action(question_attempt_pending_step $pendingstep) {        foreach ($this->question->available_specific_hint_types() as $hintkey => $hintdescription) {            if ($pendingstep->has_behaviour_var($hintkey.'btn')) {                return $this->process_hint($pendingstep, $hintkey);            }        }        return parent::process_action($pendingstep);    }    public function process_hint(question_attempt_pending_step $pendingstep, $hintkey) {        $status = $this->process_save($pendingstep);        $response = $pendingstep->get_qt_data();        if (!$this->question->hint_available($hintkey, $response)) {//Couldn't compute hint for such response            return question_attempt::DISCARD;        }        //Set hint variables        $pendingstep->set_behaviour_var('_hashint',true);        $prevhintcount = $this->qa->get_last_behaviour_var('_'.$hintkey.'count', 0);        $pendingstep->set_behaviour_var('_'.$hintkey.'count', $prevhintcount + 1);        $prevtotal = $this->qa->get_last_behaviour_var('_totalpenalties', 0);        $pendingstep->set_behaviour_var('_totalpenalties', $prevtotal + $this->question->penalty_for_specific_hint($hintkey, $response));        //process data from last graded state (e.g. submit)        $prevstep = $this->qa->get_last_step_with_behaviour_var('_try');        $pendingstep->set_fraction($prevstep->get_fraction());        if ($prevstep->get_state() == question_state::$complete) {            $pendingstep->set_state(question_state::$complete);        } else {            $pendingstep->set_state(question_state::$todo);        }        $pendingstep->set_behaviour_var('_rawfraction', $prevstep->get_behaviour_var('_rawfraction'));        $pendingstep->set_new_response_summary($this->question->summarise_response($response));        return question_attempt::KEEP;    }    //Overload process_submit to recalculate fraction and add _totalpenalties    public function process_submit(question_attempt_pending_step $pendingstep) {        $status = parent::process_submit($pendingstep);         if (!$this->question->is_gradable_response($response) && $status == question_attempt::KEEP) {//state was graded            $prevtotal = $this->qa->get_last_behaviour_var('_totalpenalties', 0);            //fraction = rawfraction - totalpenalties (already collected)            $pendingstep->set_fraction($pendingstep->get_behaviour_var('_rawfraction') - $prevtotal);            $pendingstep->set_behaviour_var('_totalpenalties', $prevtotal + $this->question->penalty);        }        return $status;    }}