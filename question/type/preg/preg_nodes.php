<?php
/**
 * Defines generic node classes, generated by parser.
 * The will be usually aggregated in engine-specific classes.
 * These classes are used primarily to store data, so their variable memebers are public
 *
 * @copyright &copy; 2010 Sychev Oleg, Kolesov Dmitriy
 * @author Sychev Oleg, Volgograd State Technical University
 * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
 * @package questions
 */

/**
 * Class for plain lexems (that are not complete nodes), so they could contain position information too.
 */
class preg_lexem {
    //Subtype of lexem
    public $subtype;
    //Indexes of first and last characters for the lexem, they are equal if it's one-character lexem
    public $indfirst = -1;
    public $indlast = -1;

    public function __construct($subtype, $indfirst, $indlast) {
        $this->subtype = $subtype;
        $this->indfirst = $indfirst;
        $this->indlast = $indlast;
    }
}

/**
 * Class for plain subpattern lexems.
 */
class preg_lexem_subpatt extends preg_lexem {
    //Number of subpattern
    public $number;

    public function __construct($subtype, $indfirst, $indlast, $number) {
        parent::__construct($subtype, $indfirst, $indlast);
        $this->number = $number;
    }
}

/**
 * The interface for objects that are passed to preg_leaf::match(), preg_leaf::consumes(), preg_leaf::next_character() as $matcherstateobj.
 */
interface qtype_preg_matcher_state {

    /**
     * Returns index of the first character matched for the given subpattern.
     */
    public function index_first($subpattern = 0);

    /**
     * Returns length of the given subpattern.
     */
    public function length($subpattern = 0);

    /**
     * Returns whether the given subpattern is captured.
     */
    public function is_subpattern_captured($subpattern);
}

/**
 * Generic node class
 */
abstract class preg_node {

    //////Class constants used to define type
    //Abstract node class, not representing real things
    const TYPE_ABSTRACT = 'abstract';
    //Character or character class
    const TYPE_LEAF_CHARSET = 'leaf_charset';
    //Meta-character or escape sequence matching with a set of characters that couldn't be enumerated
    const TYPE_LEAF_META = 'leaf_meta';
    //Simple assert: ^ $ or escape-sequence
    const TYPE_LEAF_ASSERT = 'leaf_assert';
    //Back reference to subpattern
    const TYPE_LEAF_BACKREF = 'leaf_backref';
    //Recursive match
    const TYPE_LEAF_RECURSION = 'leaf_recursion';
    //Option set
    const TYPE_LEAF_OPTIONS = 'leaf_options';
    //Combination of few leaf
    const TYPE_LEAF_COMBO = 'leaf_combo';

    //Finite quantifier
    const TYPE_NODE_FINITE_QUANT = 'node_finite_quant';
    //Infinite quantifier
    const TYPE_NODE_INFINITE_QUANT = 'node_infinite_quant';
    //Concatenation
    const TYPE_NODE_CONCAT = 'node_concat';
    //Alternative
    const TYPE_NODE_ALT = 'node_alt';
    //Assert with expression within
    const TYPE_NODE_ASSERT = 'node_assert';
    //Subpattern
    const TYPE_NODE_SUBPATT = 'node_subpatt';
    //Conditional subpattern
    const TYPE_NODE_COND_SUBPATT = 'node_cond_subpatt';
    //error node
    const TYPE_NODE_ERROR = 'node_error';

    //Member variables, common to all subclasses
    //Type, one of the class  - must return constants defined in this class
    public $type;
    //Subtype, defined by child class
    public $subtype;
    //Error data for the subtype
    public $error = false;
    //Indexes of first and last characters for the node, they are equal if it's one-character node
    public $indfirst = -1;
    public $indlast = -1;

    public function __construct() {
        $this->type = self::TYPE_ABSTRACT;
    }

    /**
    * Return class name without 'preg_' prefix
    * Interface string for the node name should be exactly same (and start from upper-case character)
    * if class not overloading ui_nodename function
    */
    abstract public function name();


    //May be overloaded by childs to change name using data from $this->pregnode
    public function ui_nodename() {
        return get_string($this->name(), 'qtype_preg');
    }

}

/**
* Generic leaf node class
*
*/
abstract class preg_leaf extends preg_node {

    //Is matching case insensitive?
    public $caseinsensitive = false;
    //Is leaf negative?
    public $negative = false;
    //Assertions, merged into this node (preg_leaf_assert objects)
    public $mergedassertions = array();

    /**
     * Returns number of characters consumed by this leaf: 0 in case of an assertion or eps-leaf, 1 in case of a single character, n in case of a backreferense
     * @param matcherstateobj an object which implements qtype_preg_matcher_state interface.
     */
    public function consumes($matcherstateobj = null) {
        return 1;
    }

    /**
     * Returns true if character(s) starting from $str[$pos] matches with leaf, false otherwise
     * Contains universal code to deal with merged assertions. Overload match_inner to define you leaf type matching
     * @param str the string being matched
     * @param pos position of character in the string, if leaf is no-consuming than position before this character analyzed
     * @param length an integer variable to store the length of the match
     * @param cs case sensitivity of the match
     * @param matcherstateobj an object which implements qtype_preg_matcher_state interface.
     */
    public function match($str, $pos, &$length, $cs, $matcherstateobj = null)
    {
        $result = true;
        //Check merged assertions
        foreach($this->mergedassertions as $assert) {
            $result = $result && $assert->match($str, $pos, $length, $cs);
        }
        //Now check this leaf
        if ($result) {
            $result = $this->match_inner($str, $pos, $length, $cs, $matcherstateobj);
        }

        return $result;
    }

    /**
     * Returns true if character(s) starting from $str[$pos] matches with leaf, false otherwise
     * Implements details of particular leaf matching
     * @param str the string being matched
     * @param pos position of character in the string, if leaf is no-consuming than position before this character analyzed
     * @param length an integer variable to store the length of the match
     * @param cs case sensitivity of the match
     * @param matcherstateobj an object which implements qtype_preg_matcher_state interface.
     */
    abstract protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null);

    /*
    * Returns a character suitable for both this leaf and merged assertions and previous character
    * @param str string already matched
    * @param pos position of the last matched character in the string
    * @param length number of characters matched in case of partial backreference match
    * @param matcherstateobj an object which implements qtype_preg_matcher_state interface.
    */
    abstract public function next_character($str, $pos, $length = 0, $matcherstateobj = null);

    /**
    * function gives leaf in human readable form
    * @return human readable form of leaf
    */
    abstract public function tohr();

    /**
    * When clonning a leaf we want a copy of the merged assertions
    */
    public function __clone() {
        foreach ($this->mergedassertions as $i => $mergedassertion) {
            $this->mergedassertions[$i] = clone $mergedassertion;
        }
    }
}

/**
*Character or charcter class
*/
class preg_leaf_charset extends preg_leaf {
    public function __construct() {
        $this->type = preg_node::TYPE_LEAF_CHARSET;
        $this->ranges = array();
        //$this->flags = array(array());
        $this->israngecalculated = true;//empty ranges for empty leaf is correct!
    }
    public $flags;//simple flags in disjunctive normal form
    /*
    *simple ranges, range is pair of integer, ranges is 3d array of integer
    *or 2d array of pair (DNF of pair)
    */
    protected $ranges;
    protected $asserts;//array of assert flag (assert impossible to calculate as range), each asserts[i] is array of 0/1/2 asserts as flag; for ranges[i]
    public $negative;
    //true if charset is DNF range matrix, false if charset is DNF of flags
    public $israngecalculated;

    public function name() {
        return 'leaf_charset';
    }
    protected function calc_ranges() {
        $this->israngecalculated = true;
        die('implement range calulate before use it!');
    }
    protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null) {
        $result = false;
        if ($this->flags === null) {
            return false;
        }
        foreach ($this->flags as $variant) {
            if (count($variant) > 0) {
                $varres = true;
                foreach ($variant as $flag) {
                    $varres &= $flag->match($str, $pos, $cs);
                }
            }
            if ($varres) {
                $result = true;
                break;
            }
        }
        if ($this->negative) {
            $result = !$result;
        }
        ($result === true) ? $length = 1 : $length = 0;
        return $result;
    }
    public function next_character($str, $pos, $length = 0, $matcherstateobj = null) {//may be rename to character?
        for ($i=ord('a'); $i<256; $i++) {
            $c=chr($i);
            if ($this->match($c, 0, $l, true)) {
                return $c;
            }
        }
        for ($i=0; $i<ord('a'); $i++) {
            $c=chr($i);
            if ($this->match($c, 0, $l, true)) {
                return $c;
            }
        }
    }
    /**
    *function check that other charset included in this
    *it's meaning that any character matching with other match with this
    *@param other charset for checking including
    *@return true if included, false otherwise
    */
    public function is_include(preg_leaf_charset $other) {
        for ($i=32; $i<126; $i++) {
            $c=chr($i);
            if (!$this->match($c, 0, $l, true) && $other->match($c, 0, $l, true)) {//matching with other and not matching with this mean - not included!
                return false;
            }
        }
        return true;
    }
    public function is_part_ident(preg_leaf_charset $other) {
        $flag1=false;
        $flag2=false;
        for ($i=32; $i<126; $i++) {
            $c=chr($i);
            if ($this->match($c, 0, $l, true) && $other->match($c, 0, $l, true)) {//matching with other and not matching with this mean - not included!
                $flag1=true;
            }
            if (!$this->match($c, 0, $l, true) && $other->match($c, 0, $l, true) || $this->match($c, 0, $l, true) && !$other->match($c, 0, $l, true)) {//matching with other and not matching with this mean - not included!
                $flag2=true;
            }
        }
        return $flag1 && $flag2;
    }

    public function tohr() {
        return 'implement tohr before use!';
    }
    public function add_flag_dis(preg_charset_flag $flag) {
        echo 'implement add_flag before use!';
    }
    public function add_flag_con(preg_charset_flag $flag) {
        echo 'implement add_flag before use!';
    }
    public function push_negative() {
        if (!$this->negative) {
            return;
        }
        if ($this->flags===null) {
            return;
        }
        if (is_array($this->flags) && isset($this->flags[0]) && is_array($this->flags[0]) && isset($this->flags[0][0])) {
            if (is_array($this->flags) && isset($this->flags[1]) && is_array($this->flags[1])) {
                $this->flags[0] = $this->flags[1];
            }
        }
        $result = $this->flags[0];
        foreach ($this->flags as $i=>$disjunct) {
            if ($i!=0) {
                $result2 = array();
                foreach ($result as $resflag) {
                    foreach ($disjunct as $disflag) {
                        if (is_array($resflag)) {
                            $tmp = $resflag;
                        } else {
                            $tmp = array($resflag);
                        }
                        $tmp[] = $disflag;
                        $result2[] = $tmp;
                    }
                }
                $result = $result2;
            }
        }
        foreach ($this->flags as $i=>$disjunct) {
            foreach ($this->flags[$i] as $j=>$flag) {
                $this->flags[$i][$j] = clone $this->flags[$i][$j];
                $this->flags[$i][$j]->negative = !$this->flags[$i][$j]->negative;
            }
        }
        $this->reduce_dnf();
    }
    //return intersection
    public function intersect(preg_leaf_charset $other) {
        if ($this->negative) {
            $this->push_negative();
        }
        if ($other->negative) {
            $other->push_negative();
        }
        foreach ($this->flags as $disjunct1) {
            foreach ($other->flags as $disjunct2) {
                $resflags[] = array_merge($disjunct1, $disjunct2);
            }
        }
        $result = new preg_leaf_charset;
        $result->flags = $resflags;
        $result->israngecalculated = false;
        $result->reduce_dnf();
        return $result;
    }
    public function reduce_dnf() {
        if ($this->flags===null) {
            return;
        }
        $working = false;
        foreach ($this->flags as $key=>$disjunct) {
            foreach ($this->flags[$key] as $index=>$flag) {
                if (is_array($this->flags) && isset($this->flags[$key]) && is_array($this->flags[$key]) && isset($this->flags[$key][$index])) {
                    if ($flag->type===preg_charset_flag::SET && !$flag->negative) {
                        foreach ($disjunct as $flag2) {
                            $this->flags[$key][$index] = $this->flags[$key][$index]->intersect($flag2);
                            if ($this->flags[$key][$index]===null) {
                                $this->flags[$key]=null;
                                break;
                            }
                        }
                        $this->flags[$key] = array($this->flags[$key][$index]);
                    } else if ($flag->type===preg_charset_flag::SET || $flag->type===preg_charset_flag::FLAG) {//negative set or flag
                        foreach ($disjunct as $i=>$flag2) {
                            if (is_array($this->flags) && isset($this->flags[$key]) && is_array($this->flags[$key]) && isset($this->flags[$key][$i])) {
                                $intersected = $this->flags[$key][$index]->intersect($flag2);
                                if ($intersected===null) {
                                    $this->flags[$key]=null;
                                    break;
                                } else if ($intersected!==false) {
                                    $this->flags[$key][$index] = $intersected;
                                    if ($i!=$index) {
                                        $working=true;
                                        $this->flags[$key][$i] = null;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        $dnf = null;
        foreach ($this->flags as $disjunct) {
            if ($disjunct!==null) {
                $disj = null;
                foreach ($disjunct as $flag) {
                    if ($flag!==null) {
                        $disj[] = $flag;
                    }
                }
                if ($disj!==null) {
                    $dnf[] = $disj;
                }
            }
        }
        $this->flags = $dnf;
        if ($working) {
            $this->reduce_dnf();
        }
    }
    public function substract(preg_leaf_charset $other) {
        $other->negative = !$other->negative;
        return $this->intersect($other);
    }
    /**
     * Returns number of characters consumed by this leaf: 0 in case of an assertion or eps-leaf, 1 in case of a single character, n in case of a backreferense
     * @param matcherstateobj an object which implements qtype_preg_matcher_state interface.
     */
    public function consumes($matcherstateobj = null) {
        return 1;
    }
}

/**
*one requirement to character
*/
class preg_charset_flag {
    //types
    const SET = 'enumerable_characters';
    const FLAG = 'functionally_calculated_characters';
    const UPROP = 'unicode_property';
    const CIRCUMFLEX = 'circumflex';
    const DOLLAR = 'dollar';

    public $negative;
    public $type;
    public $set;
    public $flag;//as name of character verify function, see constants bellow
    public $uniprop;

    static protected $flagtypes;
    static protected $intersection;


    public function set_circumflex() {
        $this->type = self::CIRCUMFLEX;
    }
    public function set_dollar() {
        $this->type = self::DOLLAR;
    }
    public function set_set($set) {
        $this->type = self::SET;
        $this->set = $set;
    }
    public function set_flag($flag) {
        $this->type = self::FLAG;
        $this->flag = $flag;
    }
    public function set_uprop($prop) {
        $this->type = self::UPROP;
        $this->uniprop = '/\\p{'.$prop.'}/';
    }
    public function is_null_length() {
        return $this->type===self::CIRCUMFLEX || $this->type===self::DOLLAR;
    }
    public function match($str, $pos, $cs = true) {
        if ($pos < 0 || $pos >= qtype_preg_unicode::strlen($str)) {
            return false;// string index out of border
        }
        switch ($this->type) {
            case self::CIRCUMFLEX:
                $result = $pos === 0;
                break;
            case self::DOLLAR:
                $result = $pos === qtype_preg_unicode::strlen($str) - 1;
                break;
            case self::SET:
                if ($pos >= qtype_preg_unicode::strlen($str)) {
                    return false;
                }
                $charsetcopy = $this->set;
                $strcopy = $str;
                if (!$cs) {
                    $charsetcopy = qtype_preg_unicode::strtolower($charsetcopy);
                    $strcopy = qtype_preg_unicode::strtolower($strcopy);
                }
                $result = (qtype_preg_unicode::strpos($charsetcopy, qtype_preg_unicode::substr($strcopy, $pos, 1)) !== false);
                break;
            case self::FLAG:
                $result = call_user_func_array($this->flag, array(qtype_preg_unicode::substr($str, $pos, 1)));
                break;
            case self::UPROP:
                $result = call_user_func_array('preg_match', array($this->uniprop, qtype_preg_unicode::substr($str, $pos, 1)));
                $result = (bool)$result;
                break;
        }
        if ($this->negative) {
            $result = !$result;
        }
        return $result;
    }
    /**
    *intersect this flag with other, if possible
    *@param other other flag to intersection
    *@return result of intersection as preg_charset flag, if intersection is possible, null if intersection is empty and false if intersection is impossible
    */
    public function intersect(preg_charset_flag $other) {
        if ($this->type==preg_charset_flag::FLAG && $other->type==preg_charset_flag::FLAG) {
            foreach (self::$flagtypes as $index=>$flagtype) {
                if ($flagtype===$this->flag) {
                    if ($this->negative) {
                        $selfindex = $index+13;
                    } else {
                        $selfindex = $index;
                    }
                    break;
                }
            }
            foreach (self::$flagtypes as $index=>$flagtype) {
                if ($flagtype===$other->flag) {
                    if ($other->negative) {
                        $otherindex = $index+13;
                    } else {
                        $otherindex = $index;
                    }
                    break;
                }
            }
            $result = self::$intersection[26 * $selfindex + $otherindex];
            if ($result===false || $result===null) {
                return $result;
            } else if ($result=='set') {
                return false;
            } else {
                $res = new preg_charset_flag;
                if ($result[0]=='-') {
                    $res->set_flag(qtype_preg_unicode::substr($result, 1));
                    $res->negative = true;
                } else {
                    $res->set_flag($result);
                }
                return $res;
            }
        } else if ($this->type==preg_charset_flag::FLAG && $other->type==preg_charset_flag::SET) {
            if ($other->negative) {
                return false;
            }
            $res = new preg_charset_flag;
            $str = '';
            for ($i=0; $i<qtype_preg_unicode::strlen($other->set); $i++) {
                if ($this->match($other->set, $i)) {
                    $str .= $other->set[$i];
                }
            }
            if ($str==='') {
                return null;
            }
            $res->set_set($str);
            return $res;
        } else if ($this->type==preg_charset_flag::SET && $other->type==preg_charset_flag::FLAG) {
            return $other->intersect($this);
        } else if ($this->type==preg_charset_flag::SET && $other->type==preg_charset_flag::SET) {
            if ($this->negative && $other->negative) {
                $res = new preg_charset_flag;
                $str = $str = $this->set . $other->set;
                $resstr = '';
                for ($i=0; $i<qtype_preg_unicode::strlen($str); $i++) {
                    if (qtype_preg_unicode::strpos($str, $str[$i])==$i) {
                        $resstr .= $str[$i];
                    }
                }
                $res->negative = true;
                if ($resstr==='') {
                    return null;
                }
                $res->set_set($resstr);
            } else if ($this->negative && !$other->negative) {
                $res = new preg_charset_flag;
                $str = '';
                for ($i=0; $i<qtype_preg_unicode::strlen($other->set); $i++) {
                    if ($this->match($other->set, $i)) {
                        $str .= $other->set[$i];
                    }
                }
                if ($str==='') {
                    return null;
                }
                $res->set_set($str);
                return $res;
            } else {
                $res = new preg_charset_flag;
                $str = '';
                for ($i=0; $i<qtype_preg_unicode::strlen($this->set); $i++) {
                    if ($other->match($this->set, $i)) {
                        $str .= $this->set[$i];
                    }
                }
                if ($str==='') {
                    return null;
                }
                $res->set_set($str);
                return $res;
            }
            return $res;
        } else {
            return false;
        }
    }
    /**
    *substract this flag with other, if possible
    *@param other other flag to substraction
    *@return result of substraction as preg_charset flag, if substraction is possible, null if substraction is empty and false if substraction is impossible
    */
    public function substract(preg_charset_flag $other) {
        $copy = clone $pther;
        return $this->intersect($copy);
    }

    /**
    *function get and return char code range for this flag
    *@return range as array[2] of integer or array of ranges (for set) as array[size][2] of integer
    */
    public function get_range() {
        die('implement get_range before use i1!');
    }

    static protected function is_wordchar($char) {
        if (ctype_alnum($char) || $char === '_') {
            return true;
        } else {
            return false;
        }
    }
    static protected function is_ascii($char) {
        return ord($char)>=0 && ord($char)<=127;
    }

    const DIGIT = 'ctype_digit';            //\d AND [:digit:]
    const XDIGIT = 'ctype_xdigit';            //[:xdigit:]
    const SPACE = 'ctype_space';             //\s AND [:space:]
    const WORDCHAR = 'self::is_wordchar';    //\w AND [:word:]
    const ALNUM = 'ctype_alnum';            //[:alnum:]
    const ALPHA = 'ctype_alpha';            //[:alpha:]
    const ASCII = 'self::is_ascii';            //[:ascii:]
    const CNTRL = 'ctype_cntrl';            //[:ctrl:]
    const GRAPH = 'ctype_graph';            //[:graph:]
    const LOWER = 'ctype_lower';            //[:lower:]
    const UPPER = 'ctype_upper';            //[:upper:]
    const PRIN = 'ctype_print';                //[:print:] PRIN, because PRINT is php keyword
    const PUNCT = 'ctype_punct';            //[:punct:]

    public function __construct() {
        if (!is_array(self::$intersection)) {
            self::$flagtypes = array(self::DIGIT, self::XDIGIT, self::SPACE, self::WORDCHAR, self::ALNUM, self::ALPHA, self::ASCII, self::CNTRL, self::GRAPH, self::LOWER, self::UPPER, self::PRIN, self::PUNCT);
            self::$intersection = array( //        digit,            xdigit,            space,            wordchar,        alnum,            alpha,            ascii,            cntrl,            graph,            lower,            upper,            print,            punct,            ndigit,                nxdigit,                nspace,                nwordchar,            nalnum,                nalpha,                nascii,                ncntrl,                ngraph,                nlower,                nupper,                nprint,            npunct
                                /*digit*/        self::DIGIT,    self::DIGIT,    null,            self::DIGIT,    self::DIGIT,    null,            'set',            null,            self::DIGIT,    null,            null,            self::DIGIT,    null,            null,                null,                    self::DIGIT,        null,                null,                self::DIGIT,        false,                self::DIGIT,        null,                self::DIGIT,        self::DIGIT,        null,            self::DIGIT,
                                /*xdigit*/        self::DIGIT,    self::XDIGIT,    null,            self::XDIGIT,    self::XDIGIT,    'set',            'set',            null,            self::XDIGIT,    'set',            'set',            self::XDIGIT,    null,            'set',                null,                    self::XDIGIT,        null,                null,                self::DIGIT,        false,                self::XDIGIT,        null,                false,                false,                null,            self::XDIGIT,
                                /*space*/        null,            null,            self::SPACE,    null,            null,            null,            'set',            null,            null,            null,            null,            self::SPACE,    null,            self::SPACE,        self::SPACE,            null,                self::SPACE,        self::SPACE,        self::SPACE,        false,                self::SPACE,        self::SPACE,        self::SPACE,        self::SPACE,        null,            self::SPACE,
                                /*wordchar*/     self::DIGIT,    self::XDIGIT,    null,            self::WORDCHAR,    self::ALNUM,    self::ALPHA,    'set',            null,            self::WORDCHAR,    self::LOWER,    self::UPPER,    self::WORDCHAR,    null,            self::ALNUM,        false,                    self::WORDCHAR,        null,                'set',                false,                false,                self::WORDCHAR,        null,                false,                false,                null,            self::WORDCHAR,
                                /*alnum*/        self::DIGIT,    self::XDIGIT,    null,            self::ALNUM,    self::ALNUM,    self::ALPHA,    'set',            null,            self::ALNUM,    self::LOWER,    self::UPPER,    self::ALNUM,    null,            self::ALPHA,        false,                    self::ALNUM,        null,                null,                self::DIGIT,        false,                self::ALNUM,        null,                false,                false,                null,            self::ALNUM,
                                /*alpha*/        null,            false,            null,            self::ALPHA,    self::ALPHA,    self::ALPHA,    'set',            null,            self::ALPHA,    self::LOWER,    self::UPPER,    self::ALPHA,    null,            self::ALPHA,        false,                    self::ALPHA,        null,                null,                null,                false,                self::ALPHA,        null,                self::UPPER,        self::LOWER,        null,            self::ALPHA,
                                /*ascii*/        'set',            'set',            'set',            'set',            'set',            'set',            self::ASCII,    'set',            'set',            'set',            'set',            'set',            'set',            'set',                'set',                    'set',                'set',                'set',                'set',                null,                'set',                'set',                'set',                'set',                'set',            'set',
                                /*cntrl*/        null,            null,            null,            null,            null,            null,            'set',            self::CNTRL,    false,            null,            null,            false,            null,            self::CNTRL,        self::CNTRL,            self::CNTRL,        self::CNTRL,        self::CNTRL,        self::CNTRL,        false,                null,                false,                self::CNTRL,        self::CNTRL,        false,            false,
                                /*graph*/        self::DIGIT,    self::XDIGIT,    null,            self::WORDCHAR,    self::ALNUM,    self::ALPHA,    'set',            false,            self::GRAPH,    self::LOWER,    self::UPPER,    self::PRIN,        false,            false,                false,                    false,                false,                false,                false,                false,                false,                null,                false,                false,                false,            false,
                                /*lower*/        null,            null,            null,            self::LOWER,    self::LOWER,    self::LOWER,    'set',            null,            self::LOWER,    self::LOWER,    null,            self::LOWER,    null,            self::LOWER,        false,                    self::LOWER,        null,                null,                null,                false,                self::LOWER,        null,                null,                self::LOWER,        null,            self::LOWER,
                                /*upper*/        null,            null,            null,            self::UPPER,    self::UPPER,    self::UPPER,    'set',            null,            self::UPPER,    null,            self::UPPER,    self::UPPER,    null,            self::UPPER,        false,                    self::UPPER,        null,                null,                null,                false,                self::UPPER,        null,                self::UPPER,        null,                null,            self::UPPER,
                                /*print*/        self::DIGIT,    self::XDIGIT,    self::SPACE,    self::WORDCHAR,    self::ALNUM,    self::ALPHA,    'set',            false,            self::GRAPH,    self::LOWER,    self::UPPER,    self::PRIN,        self::PUNCT,    false,                false,                    false,                false,                false,                false,                false,                false,                false,                false,                false,                null,            false,
                                /*punct*/        null,            null,            null,            null,            null,            null,            'set',            false,            null,            null,            null,            self::PUNCT,    self::PUNCT,    self::PUNCT,        self::PUNCT,            self::PUNCT,        self::PUNCT,        self::PUNCT,        self::PUNCT,        false,                false,                self::PUNCT,        self::PUNCT,        self::PUNCT,        null,            null,
                                /*ndigit*/        null,            'set',            self::SPACE,    self::ALNUM,    self::ALPHA,    self::ALPHA,    'set',            self::CNTRL,    false,            self::LOWER,    self::UPPER,    false,            self::PUNCT,    '-'.self::DIGIT,    '-'.self::XDIGIT,        false,                '-'.self::WORDCHAR,    '-'.self::ALNUM,    '-'.self::ALNUM,    false,                false,                '-'.self::GRAPH,    false,                false,                '-'.self::PRIN,    false,
                                /*nxdigit*/        null,            null,            self::SPACE,    false,            false,            false,            'set',            self::CNTRL,    false,            self::LOWER,    false,            false,            self::PUNCT,    '-'.self::XDIGIT,    '-'.self::XDIGIT,        false,                '-'.self::WORDCHAR,    '-'.self::ALNUM,    '-'.self::ALNUM,    false,                false,                '-'.self::GRAPH,    false,                false,                '-'.self::PRIN,    false,
                                /*nspace*/        self::DIGIT,    self::XDIGIT,    null,            self::WORDCHAR,    self::ALNUM,    self::ALPHA,    'set',            self::CNTRL,    false,            self::LOWER,    self::UPPER,    false,            self::PUNCT,    false,                false,                    '-'.self::SPACE,    false,                false,                false,                false,                false,                false,                false,                false,                '-'.self::PRIN,    false,
                                /*nwordchar*/    null,            null,            self::SPACE,    null,            null,            null,            'set',            self::CNTRL,    false,            null,            null,            false,            self::PUNCT,    '-'.self::WORDCHAR,    '-'.self::WORDCHAR,        false,                '-'.self::WORDCHAR,    '-'.self::WORDCHAR,    '-'.self::WORDCHAR,    false,                false,                '-'.self::GRAPH,    '-'.self::WORDCHAR,    '-'.self::WORDCHAR,    '-'.self::PRIN,    false,
                                /*nalnum*/        null,            null,            self::SPACE,    'set',            null,            null,            'set',            self::CNTRL,    false,            null,            null,            false,            self::PUNCT,    '-'.self::ALNUM,    '-'.self::ALNUM,        false,                '-'.self::WORDCHAR,    '-'.self::ALNUM,    '-'.self::ALNUM,    false,                false,                '-'.self::GRAPH,    '-'.self::ALNUM,    '-'.self::ALNUM,    '-'.self::PRIN,    false,
                                /*nalpha*/        self::DIGIT,    self::DIGIT,    self::SPACE,    false,            self::DIGIT,    null,            'set',            self::CNTRL,    false,            null,            null,            false,            self::PUNCT,    '-'.self::ALNUM,    '-'.self::ALNUM,        false,                '-'.self::WORDCHAR,    '-'.self::ALNUM,    '-'.self::ALPHA,    false,                false,                '-'.self::GRAPH,    '-'.self::ALPHA,    '-'.self::ALPHA,    '-'.self::PRIN,    false,
                                /*nascii*/        false,            false,            false,            false,            false,            false,            null,            false,            false,            false,            false,            false,            false,            false,                false,                    false,                false,                false,                false,                '-'.self::ASCII,    false,                false,                false,                false,                false,            false,
                                /*ncntrl*/        self::DIGIT,    self::XDIGIT,    self::SPACE,    self::WORDCHAR,    self::ALNUM,    self::ALPHA,    'set',            null,            false,            self::LOWER,    self::UPPER,    false,            false,            false,                false,                    false,                false,                false,                false,                false,                '-'.self::CNTRL,    false,                false,                false,                false,            false,
                                /*ngraph*/        null,            null,            self::SPACE,    null,            null,            null,            'set',            false,            null,            null,            null,            false,            self::PUNCT,    '-'.self::GRAPH,    '-'.self::GRAPH,        false,                '-'.self::GRAPH,    '-'.self::GRAPH,    '-'.self::GRAPH,    false,                false,                '-'.self::GRAPH,    '-'.self::GRAPH,    '-'.self::GRAPH,    '-'.self::PRIN,    false,
                                /*nlower*/        self::DIGIT,    false,            self::SPACE,    false,            false,            self::UPPER,    'set',            self::CNTRL,    false,            null,            self::UPPER,    false,            self::PUNCT,    false,                false,                    false,                '-'.self::WORDCHAR,    '-'.self::ALNUM,    '-'.self::ALPHA,    false,                false,                '-'.self::GRAPH,    '-'.self::LOWER,    '-'.self::ALPHA,    '-'.self::PRIN,    false,
                                /*nupper*/        self::DIGIT,    false,            self::SPACE,    false,            false,            self::LOWER,    'set',            self::CNTRL,    false,            self::LOWER,    null,            false,            self::PUNCT,    false,                false,                    false,                '-'.self::WORDCHAR,    '-'.self::ALNUM,    '-'.self::ALPHA,    false,                false,                '-'.self::GRAPH,    '-'.self::ALPHA,    '-'.self::UPPER,    '-'.self::PRIN,    false,
                                /*nprint*/        null,            null,            null,            null,            null,            null,            'set',            false,            false,            null,            null,            null,            null,            '-'.self::PRIN,        '-'.self::PRIN,    '-'.    self::PRIN,            '-'.self::PRIN,        '-'.self::PRIN,        '-'.self::PRIN,        false,                false,                '-'.self::PRIN,        '-'.self::PRIN,        '-'.self::PRIN,        '-'.self::PRIN,    '-'.self::PRIN,
                                /*npunct*/        self::DIGIT,    self::XDIGIT,    self::SPACE,    self::WORDCHAR,    self::ALNUM,    self::ALPHA,    'set',            false,            false,            self::LOWER,    self::UPPER,    false,            null,            false,                false,                    false,                false,                false,                false,                false,                false,                false,                false,                false,                '-'.self::PRIN,    '-'.self::PUNCT
                                );
        }
    }
}

/**
* Meta-character or escape sequence defining character set that couldn't be enumerated
*/
class preg_leaf_meta extends preg_leaf {

    //. - any character except \n
    const SUBTYPE_DOT = 'dot_leaf_meta';
    //\p{L} or \pL
    const SUBTYPE_UNICODE_PROP = 'unicode_prop_leaf_meta';
    // \w
    //Should be locale-aware, but not Unicode for PCRE-compatibility
    const SUBTYPE_WORD_CHAR = 'word_char_leaf_meta';
    //Leaf with empty in alternative (something|)
    const SUBTYPE_EMPTY = 'empty_leaf_meta';
    //Service subtype - end of regex, but not end of string
    const SUBTYPE_ENDREG = 'endreg_leaf_meta';
    //Unicode property name, used in case of SUBTYPE_UNICODE_PROP
    public $propname = '';
    //true if charset is DNF range matrix, false if charset is DNF of flags
    public $israngecalculated;

    public function __construct() {
        $this->type = preg_node::TYPE_LEAF_META;
    }
    public function name() {
        return 'leaf_meta';
    }

    //TODO - ui_nodename()

    public function consumes($matcherstateobj = null) {
        if ($this->subtype == preg_leaf_meta::SUBTYPE_EMPTY) {
            return 0;
        }
        return 1;
    }

    public function next_character($str, $pos, $length = 0, $matcherstateobj = null) {
        switch ($this->subtype) {
            case preg_leaf_meta::SUBTYPE_DOT:
                $result = 'D';
                break;
            //TODO: unicode property
            case preg_leaf_meta::SUBTYPE_WORD_CHAR:
                if ($this->negative) {
                    $result = '#';
                } else {
                    $result = 'W';
                }
                break;
        }
        return $result;
    }

    protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null) {
        if ($this->subtype == preg_leaf_meta::SUBTYPE_EMPTY) {
            $length = 0;
            return true;
        }
        if ($pos >= qtype_preg_unicode::strlen($str)) {
            $length = 0;
            return false;
        }
        switch ($this->subtype) {
            case preg_leaf_meta::SUBTYPE_DOT:
                if ($pos < qtype_preg_unicode::strlen($str) && qtype_preg_unicode::substr($str, $pos, 1) != "\n") {
                    $length = 1;
                    return true;
                } else {
                    $length = 0;
                    return false;
                }
                break;
            //TODO: unicode property
            case preg_leaf_meta::SUBTYPE_WORD_CHAR:
                if (ctype_alnum(qtype_preg_unicode::substr($str, $pos, 1)) || qtype_preg_unicode::substr($str, $pos, 1) === '_') {
                    $result =  true;
                } else {
                    $result =  false;
                }
                break;
            case preg_leaf_meta::SUBTYPE_EMPTY:
                $length = 0;
                return true;
                break;
        }
        if ($this->negative) {
            $result = !$result;
        }
        if ($result) {
            $length = 1;
        } else {
            $length = 0;
        }
        return $result;
    }

    public function tohr() {
        if ($this->negative) {
            $direction = '!';
        } else {
            $direction = '';
        }
        switch ($this->subtype) {
            case preg_leaf_meta::SUBTYPE_WORD_CHAR:
                $type = '\\w';
                break;
            case preg_leaf_meta::SUBTYPE_DOT:
                $type = 'dot';
                break;
            case preg_leaf_meta::SUBTYPE_ENDREG:
                $type = 'ENDREG';
                break;
            case preg_leaf_meta::SUBTYPE_EMPTY:
                $type = 'eps';
                break;
        };
        $result = "$direction"."meta$type";
        return $result;
    }
}

/**
* Meta-character or escape sequence defining character set that couldn't be enumerated
*/
class preg_leaf_assert extends preg_leaf {

    //^
    const SUBTYPE_CIRCUMFLEX = 'circumflex_leaf_assert';
    //$
    const SUBTYPE_DOLLAR = 'dollar_leaf_assert';
    // \b
    const SUBTYPE_WORDBREAK = 'wordbreak_leaf_assert';
    // \A
    const SUBTYPE_ESC_A = 'esc_a_leaf_assert';
    // \z
    const SUBTYPE_ESC_Z = 'esc_z_leaf_assert';
    // \G
    const SUBTYPE_ESC_G = 'esc_g_leaf_assert';

    //Reference to the matcher object to be able to query it for captured subpattern
    //Filled only to ESC_G subtype if it would be implemented in the future
    public $matcher;

    public function __construct() {
        $this->type = preg_node::TYPE_LEAF_ASSERT;
    }

    public function consumes($matcherstateobj = null) {
        return 0;
    }

    public function name() {
        return 'leaf_assert';
    }

    //TODO - ui_nodename()
    protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null) {
        $length = 0;
        switch ($this->subtype) {
            case preg_leaf_assert::SUBTYPE_ESC_A://because may be one line only is response
            case preg_leaf_assert::SUBTYPE_ESC_G://there are no repetitive matching for now, so \G is equvivalent to \A
            case preg_leaf_assert::SUBTYPE_CIRCUMFLEX:
                if($pos == 0) {
                    $result = true;
                } else {
                    $result = false;
                }
                break;
            case preg_leaf_assert::SUBTYPE_ESC_Z://because may be one line only is response
            case preg_leaf_assert::SUBTYPE_DOLLAR:
                if ($pos == qtype_preg_unicode::strlen($str)) {
                    $result = true;
                } else {
                    $result = false;
                }
                break;
            case preg_leaf_assert::SUBTYPE_WORDBREAK:
                $start = $pos == 0 && (qtype_preg_unicode::substr($str, 0, 1) == '_' || ctype_alnum(qtype_preg_unicode::substr($str, 0, 1)));
                $end = $pos == qtype_preg_unicode::strlen($str) && (qtype_preg_unicode::substr($str, $pos - 1, 1) == '_' || ctype_alnum(qtype_preg_unicode::substr($str, $pos - 1, 1)));
                if ($pos > 0 && $pos < qtype_preg_unicode::strlen($str)) {
                    $wW = (qtype_preg_unicode::substr($str, $pos - 1, 1) == '_' || ctype_alnum(qtype_preg_unicode::substr($str, $pos - 1, 1))) && !(qtype_preg_unicode::substr($str, $pos, 1) == '_' || ctype_alnum(qtype_preg_unicode::substr($str, $pos, 1)));
                    $Ww = !(qtype_preg_unicode::substr($str, $pos - 1, 1) == '_' || ctype_alnum(qtype_preg_unicode::substr($str, $pos - 1, 1))) && (qtype_preg_unicode::substr($str, $pos, 1) == '_' || ctype_alnum(qtype_preg_unicode::substr($str, $pos, 1)));
                } else {
                    $wW = $Ww = false;
                }
                if ($start || $end || $wW || $Ww) {
                    $result = true;
                } else {
                    $result = false;
                }
                break;
        }
        if ($this->negative) {
            $result = !$result;
        }
        return $result;
    }
    public function next_character($str, $pos, $length = 0, $matcherstateobj = null) {
        switch ($this->subtype) {
            case preg_leaf_assert::SUBTYPE_ESC_A://because may be one line only is response
            case preg_leaf_assert::SUBTYPE_CIRCUMFLEX:
                if ($this->negative) {
                    return 'notstringstart';
                } else {
                    return 'stringstart';
                }
                break;
            case preg_leaf_assert::SUBTYPE_ESC_Z://because may be one line only is response
            case preg_leaf_assert::SUBTYPE_DOLLAR:
                if ($this->negative) {
                    return ' notstringend';
                } else {
                    return '';
                }
                break;
            case preg_leaf_assert::SUBTYPE_WORDBREAK:
                if ($this->negative) {
                    return 'notwordchar';
                } else {
                    return 'wordchar';
                }
                break;
        }
    }
    public function tohr() {
        if ($this->negative) {
            $direction = '!';
        } else {
            $direction = '';
        }
        switch ($this->subtype) {
            case preg_leaf_assert::SUBTYPE_ESC_A://because may be one line only is response
            case preg_leaf_assert::SUBTYPE_CIRCUMFLEX:
                $type = '^';
                break;
            case preg_leaf_assert::SUBTYPE_ESC_Z://because may be one line only is response
            case preg_leaf_assert::SUBTYPE_DOLLAR:
                $type = '$';
                break;
            case preg_leaf_assert::SUBTYPE_WORDBREAK:
                $type = '\\b';
                break;
        };
        $result = "$direction"."assert$type";
        return $result;
    }
}

class preg_leaf_backref extends preg_leaf {
    public $number;
    //Reference to the matcher object to be able to query it for captured subpattern
    public $matcher;

    public function __construct() {
        $this->type = preg_node::TYPE_LEAF_BACKREF;
    }

    public function consumes($matcherstateobj = null) {
        if (!$matcherstateobj->is_subpattern_captured($this->number)) {
            return qtype_preg_matching_results::UNKNOWN_CHARACTERS_LEFT;
        }
        return $matcherstateobj->length($this->number);
    }

    protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null) {
        if (!$matcherstateobj->is_subpattern_captured($this->number)) {
            $length = 0;
            return false;
        }
        $len = qtype_preg_unicode::strlen($str);
        $subpattlen = $matcherstateobj->length($this->number);
        $start = $matcherstateobj->index_first($this->number);
        $end = $start + $subpattlen - 1;
        if ($subpattlen > 0 && $pos >= $len) {
            $length = 0;
            return false;
        } else if ($subpattlen == 0) {
            $length = 0;
            return true;
        }

        $strcopy = $str;
        if (!$cs) {
            $strcopy = qtype_preg_unicode::strtolower($strcopy);
        }
        $matchlen = 0;
        $result = true;
        // check char by char
        for ($i = $start; $result && $i <= $end && $matchlen + $pos < $len; $i++) {
            $result = $result && (qtype_preg_unicode::substr($strcopy, $i, 1) === qtype_preg_unicode::substr($strcopy, $pos + $matchlen, 1));
            if ($result) {
                $matchlen++;
            }
        }
        // if the string has not enough characters
        if ($pos + $subpattlen - 1 >= $len) {
            $result = false;
        }
        $length = $matchlen;
        return $result;
    }

    public function name() {
        return 'leaf_backref';
    }

    public function next_character($str, $pos, $length = 0, $matcherstateobj = null) {
        // TODO: check for assertions in case of $length == 0
        if (!$matcherstateobj->is_subpattern_captured($this->number)) {
            return '';
        }
        $start = $matcherstateobj->index_first($this->number);
        $end = $start + $matcherstateobj->length($this->number);
        if ($end > qtype_preg_unicode::strlen($str)) {
            return '';
        }
        $res = '';
        $res .= qtype_preg_unicode::substr($str, $start + $length, $end - $start - $length);
        return $res;
    }

    public function tohr() {
        return 'backref #'.$this->number;
    }
}

class preg_leaf_option extends preg_leaf {
    public $posopt;
    public $negopt;

    public function __construct() {
        $this->type = preg_node::TYPE_LEAF_OPTIONS;
    }
    protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null) {
        die ('TODO: implements abstract function match for preg_leaf_option class before use it!');
    }
    public function name() {
        return 'leaf_option';
    }
    public function next_character($str, $pos, $length = 0, $matcherstateobj = null) {
        die ('TODO: implements abstract function character for preg_leaf_option class before use it!');
    }
    public function tohr() {
        return '(?'.$this->posopt.'-'.$this->negopt;
    }
}

    //TODO - ui_nodename()
class preg_leaf_recursion extends preg_leaf {

    public $number;

    public function __construct() {
        $this->type = preg_node::TYPE_LEAF_RECURSION;
    }
    protected function match_inner($str, $pos, &$length, $cs, $matcherstateobj = null) {
        die ('TODO: implements abstract function match for preg_leaf_recursion class before use it!');
    }
    public function name() {
        return 'leaf_recursion';
    }
    public function next_character($str, $pos, $length = 0, $matcherstateobj = null){
        die ('TODO: implements abstract function character for preg_leaf_recursion class before use it!');
    }
    public function tohr() {
        return 'recursion';
    }
}


/**
* Operator node
*/
abstract class preg_operator extends preg_node {

    //An array of operands
    public $operands = array();

    /**
    * When clonning an operator we want a copy of the whole subtree, not the references to the operands
    */
    public function __clone() {
        foreach ($this->operands as $i => $operand) {
            $this->operands[$i] = clone $operand;
        }
    }

}


/**
* Finite quantifier node with left and right border
* Unary
* Possible errors: left border is greater than right one
*/
class preg_node_finite_quant extends preg_operator {

    //Is quantifier greed?
    public $greed;
    //Is quantifier posessive?
    public $posessive;
    //Smallest possible repetition number
    public $leftborder;
    //Biggest possible repetition number
    public $rightborder;

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_FINITE_QUANT;
    }

    public function name() {
        return 'node_finite_quant';
    }

    //TODO - ui_nodename()
}

/**
* Infinite quantifier node with left border only
* Unary
*/
class preg_node_infinite_quant extends preg_operator {

    //Is quantifier greed?
    public $greed;
    //Is quantifier posessive?
    public $posessive;
    //Smallest possible repetition number
    public $leftborder;

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_INFINITE_QUANT;
    }

    public function name() {
        return 'node_infinite_quant';
    }

    //TODO - ui_nodename()
}

/**
* Concatenation operator
* Binary
*/
class preg_node_concat extends preg_operator {
    public function __construct() {
        $this->type = preg_node::TYPE_NODE_CONCAT;
    }

    public function name() {
        return 'node_concat';
    }

}

/**
* Alternative operator
* Binary
*/
class preg_node_alt extends preg_operator {

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_ALT;
    }

    public function name() {
        return 'node_alt';
    }

}

/**
* Assert with expression within
* Unary
*/
class preg_node_assert extends preg_operator {

    //Positive lookahead assert
    const SUBTYPE_PLA = 'pla_node_assert';
    //Negative lookahead assert
    const SUBTYPE_NLA = 'nla_node_assert';
    //Positive lookbehind assert
    const SUBTYPE_PLB = 'plb_node_assert';
    //Negative lookbehind assert
    const SUBTYPE_NLB = 'nlb_node_assert';

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_ASSERT;
    }

    public function name() {
        return 'node_assert';
    }
    public function tohr() {
        return 'node assert';
    }

    //TODO - ui_nodename()
}

/**
* Subpattern
* Unary
*/
class preg_node_subpatt extends preg_operator {

    //Subpattern
    const SUBTYPE_SUBPATT = 'subpatt_node_subpatt';
    //Once-only subpattern
    const SUBTYPE_ONCEONLY = 'onceonly_node_subpatt';

    //Subpattern number
    public $number = 0;
    //Subpattern match (if supported)
    public $match = null;

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_SUBPATT;
    }

    public function name() {
        return 'node_subpatt';
    }

    //TODO - ui_nodename()
}

/**
* Conditional subpattern
* Unary, binary or ternary, first operand is assert expression (if any),  second - yes-pattern, third - no-pattern
* Possible errors: there is no backreference with such number in expression
*/
class preg_node_cond_subpatt extends preg_operator {

    //Subtypes define a type of condition for subpatern
    //Positive lookahead assert
    const SUBTYPE_PLA = 'pla_node_cond_subpatt';
    //Negative lookahead assert
    const SUBTYPE_NLA = 'nla_node_cond_subpatt';
    //Positive lookbehind assert
    const SUBTYPE_PLB = 'plb_node_cond_subpatt';
    //Negative lookbehind assert
    const SUBTYPE_NLB = 'nlb_node_cond_subpatt';
    //Backreference
    const SUBTYPE_BACKREF = 'backref_node_cond_subpatt';
    //Recursive
    const SUBTYPE_RECURSIVE = 'recursive_node_cond_subpatt';

    //Subpattern number
    public $number = 0;
    //Subpattern match (if supported)
    public $match = null;
    //Is condition satisfied?
    public $condbranch = null;
    //Backreference number
    public $backrefnumber = -1;

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_COND_SUBPATT;
    }

    public function name() {
        return 'node_cond_subpatt';
    }

    //TODO - ui_nodename()
}
class preg_node_error extends preg_node {

    //Subtypes define a type of error
    //Unknown parse error
    const SUBTYPE_UNKNOWN_ERROR = 'unknown_error_node_error';
    //Too much top-level alternatives in conditional subpattern
    const SUBTYPE_CONDSUBPATT_TOO_MUCH_ALTER = 'consubpatt_too_much_alter_node_error';
    //Close paren without opening  xxx)
    const SUBTYPE_WRONG_CLOSE_PAREN = 'wrong_close_paren_node_error';
    //Ending of a lexem without beginning  xxx(?#}})
    const SUBTYPE_WRONG_CLOSE_LEXEM = 'wrong_close_lexem_node_error';
    //Open paren without closing  (xxx
    const SUBTYPE_WRONG_OPEN_PAREN = 'wrong_open_paren_node_error';
    //Beginning of a lexem without ending  (?#{{)xxx
    const SUBTYPE_WRONG_OPEN_LEXEM = 'wrong_open_lexem_node_error';
    //Empty parens
    const SUBTYPE_EMPTY_PARENS = 'empty_parens_node_error';
    //Empty lexem
    const SUBTYPE_EMPTY_LEXEM = 'empty_lexem_node_error';
    //Quantifier at start of expression  - NOTE - currently incompatible with PCRE which treat it as character
    const SUBTYPE_QUANTIFIER_WITHOUT_PARAMETER = 'quantifier_without_parameter_node_error';
    //Unclosed square brackets in character class
    const SUBTYPE_UNCLOSED_CHARCLASS = 'unclosed_charclass_node_error';
    //Set and unset same modifier at ther same time
    const SUBTYPE_SET_UNSET_MODIFIER = 'set_and_unset_same_modifier_at_the_same_time_node_error';

    //Error strings name in qtype_preg.php lang file
    public static $errstrs = array( preg_node_error::SUBTYPE_UNKNOWN_ERROR => 'incorrectregex', preg_node_error::SUBTYPE_CONDSUBPATT_TOO_MUCH_ALTER => 'threealtincondsubpatt',
                                    preg_node_error::SUBTYPE_WRONG_CLOSE_PAREN => 'unopenedparen', preg_node_error::SUBTYPE_WRONG_CLOSE_LEXEM => 'unopenedlexem',
                                    preg_node_error::SUBTYPE_WRONG_OPEN_PAREN => 'unclosedparen', preg_node_error::SUBTYPE_WRONG_OPEN_LEXEM => 'unclosedlexem',
                                    preg_node_error::SUBTYPE_EMPTY_PARENS => 'emptyparens', preg_node_error::SUBTYPE_EMPTY_LEXEM => 'emptylexem',
                                    preg_node_error::SUBTYPE_QUANTIFIER_WITHOUT_PARAMETER => 'quantifieratstart', preg_node_error::SUBTYPE_UNCLOSED_CHARCLASS => 'unclosedsqbrackets',
                                    preg_node_error::SUBTYPE_SET_UNSET_MODIFIER =>'setunsetmod');

    //Arrays of indexes in regex string describing error to highlight to the user (and include in message) - first and last
    public $firstindxs;
    public $lastindxs;
    //Additional info
    public $addinfo;

    public function name() {
        return 'node_error';
    }

    public function __construct() {
        $this->type = preg_node::TYPE_NODE_ERROR;
        $this->firstindxs = array();
        $this->lastindxs = array();
        $this->addinfo = null;
    }

    /*
    * Returns an user interface error string for the error, represented by node
    */
    public function error_string() {
        $a = new stdClass;
        $a->indfirst = $this->firstindxs[0];
        $a->indlast = $this->lastindxs[0];
        $a->addinfo = $this->addinfo;
        return get_string(preg_node_error::$errstrs[$this->subtype], 'qtype_preg', $a);
    }
}


?>